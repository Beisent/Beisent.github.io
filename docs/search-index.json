[
  {
    "title": "多线程编程入门",
    "description": "C++ 多线程编程基础，包括线程创建、互斥锁、条件变量与原子操作",
    "url": "Computer/C++/Multithread/01.html",
    "content": "# 多线程编程入门\n多线程编程是一个非常强大的功能，现代 CPU 通常有多个核心，如果你不使用多线程编程那么所有的代码都会跑在同一个 CPU 核心上，其他的核心都被闲置极大的浪费的计算资源。\n# 创建一个线程\n在 C++11 及以上版本中使用多线程编程非常简单，C++11 标准提供了强大的 std::thread\n我们可以这样创建一个线程并且传递一个函数指针作为这个线程的任务，这个函数将会在创建的子线程上运行\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nvoid print() { std::cout &lt;&lt; &quot;我工作在子线程上！！&quot; &lt;&lt; std::endl; }\n\nint main() {\n  std::thread t1(print);\n  std::cout &lt;&lt; &quot;主线程结束！&quot; &lt;&lt; std::endl;\n  return 0;\n}\n编译再运行后会发现并没有按照我们的心意运行\n主线程结束！\nterminate called without an active exception\n我工作在子线程上！！\n[1]    30674 IOT instruction (core dumped)  ./a.out\n这是因为我们将任务交给子线程后主线程还会继续执行，子线程的创建和调用还会使用很多时间，但是主线程依旧继续执行并结束，子线程依旧在后台执行。   通常情况下主线程的生命周期都会比子线程长，所以我们需要让子线程等待子线程执行完毕再继续执行下面的代码，这时候我们可以这么写。\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n\nvoid print() { std::cout &lt;&lt; &quot;我工作在子线程上！！&quot; &lt;&lt; std::endl; }\n\nint main() {\n  std::thread t1(print);\n  t1.join();\n  std::cout &lt;&lt; &quot;主线程结束！&quot; &lt;&lt; std::endl;\n  return 0;\n}\n此时再执行会发现正常\n我工作在子线程上！！\n",
    "excerpt": "# 多线程编程入门\n多线程编程是一个非常强大的功能，现代 CPU 通常有多个核心，如果你不使用多线程编程那么所有的代码都会跑在同一个 CPU 核心上，其他的核心都被闲置极大的浪费的计算资源。\n# 创建一个线程\n在 C++11 及以上版本中使用多线程编程非常简单，C++11 标准提供了强大的 std::thread\n我们可以这样创建一个线程并且传递一个函数指针作为这个线程的任务，这个函数将会在创建的..."
  },
  {
    "title": "生产消费者模型",
    "description": "由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办",
    "url": "Computer/C++/Multithread/02.html",
    "content": "# 生产消费者模型\n由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃。\n所以为了解决这个问题就诞生了生产消费模型\n生产消费模型有以下特点: - 任务队列：用于堆放代办任务 - 生产者：用于生产任务   - 消费者：用于处理任务\n实现的关键挑战 - 互斥：同一时刻只能有一个线程操作队列，防止数据损坏。 - 同步：  - 队列满时，生产者必须等待，不能撑爆内存。  - 队列空时，消费者必须等待，不能空转 CPU。  - 当状态改变（有新任务或有空位）时，及时唤醒等待的线程。\n据此我们实现\n\n#include &lt;condition_variable&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;queue&gt;\n#include &lt;thread&gt;\n\nclass MessageQueue {\npublic:\n  void push(int val) {\n    // 保证此时只有一人能推送数据\n    std::unique_lock&lt;std::mutex&gt; lock(m_mutex);\n\n    // 只有当队列不满的时候并且没有结束的时候能推送数据\n    m_cv.wait(lock, [this] { return m_queue.size() &lt; m_maxSize || m_done; });\n\n    if (m_done) {\n      return;\n    }\n\n    m_queue.push(val);\n\n    std::cout &lt;&lt; &quot;生产了一个数：&quot; &lt;&lt; val &lt;&lt; &quot; 当前还剩&quot;\n              &lt;&lt; m_maxSize - m_queue.size() &lt;&lt; &quot; 个位置&quot; &lt;&lt",
    "excerpt": "# 生产消费者模型\n由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃。\n所以为了解决这个问题就诞生了..."
  },
  {
    "title": "Rust 入门",
    "description": "Rust 基本语法入门，涵盖变量、所有权、引用、控制流、结构体、枚举与 Trait",
    "url": "Computer/Rust/基本语法.html",
    "content": "# Rust 入门\n# 变量\n通过 let 在 rust 中变量默认是 不可变 的。如果要声明一个可变变量需要使用 mut 关键字\nfn main() {\n    let name = &quot;Rust 萌新&quot;;\n    \n    let mut energy = 100;\n    energy = 90;\n\n    const MAX_LEVEL: u32 = 99;\n\n    println!(&quot;玩家：{}, 体力: {}, 最高等级: {}&quot;, name, energy, MAX_LEVEL);\n}\n# 所有权\n所有权是 rust 中的核心概念。简单来说就是：一个堆区值在同一时间下只能由同一个\"人\"所有，当这个\"人“离开作用域后，该值就会被丢弃。栈区会自动发生拷贝，而堆区的值会发生移动。\nfn main() {\n    let s1 = String::from(&quot;hello&quot;);\n    \n    // 将S tring::from(&quot;hello&quot;); 的所有权从 s1 转移至s2 \n    let s2 = s1; \n\n    // println!(&quot;{}&quot;, s1); // 报错！因为 s1 的所有权已经给了 s2\n    println!(&quot;{}&quot;, s2);   // 正常运行\n}\n# 引用与借用\n但如果我们每次传参都要移动所有权，那代码就太难写了。引用(或者叫借用)允许你使用值但不取得所有权。\n引用有以下规则： 同时只能有一个可变引用&mut T 可以同时有多个不可变引用&T\nfn get_length(str: &amp;String) -&gt; usize{\n    str.len()\n}// 离开作用域后str不再指向s1的内存\n\nfn main() {\n   let s1 = String::from(&quot;hello&quot;);\n\n   // 使用 &amp; 传递不可变引用\n   let len = get_length(&amp;s1);\n\n   println!(&quot;{} 的长度是 {}&quot;,s1,len);\n}\n# 控制流与模式匹配\nRust 的 if 是表达式，而 match 是加强版的",
    "excerpt": "# Rust 入门\n# 变量\n通过 let 在 rust 中变量默认是 不可变 的。如果要声明一个可变变量需要使用 mut 关键字\nfn main() {\n    let name = &quot;Rust 萌新&quot;;\n    \n    let mut energy = 100;\n    energy = 90;\n\n    const MAX_LEVEL: u32 = 99;\n\n    p..."
  },
  {
    "title": "实数",
    "description": "实数集的稠密性与连续性，戴德金分割",
    "url": "Math/Calculus/01.html",
    "content": "# 实数\n实数集 R 区别于其他数集的最核心的两个特征是：稠密性 与 连续性。\n# 稠密性\n定义： 在实数轴上，任意两个不相等的实数之间，必然存在另一个实数。\n事实上，不仅存在一个，而是存在无穷多个实数。这一性质说明实数在直线上是“处处存在”的，不存在孤立的点。\n# 连续性\n定义： 实数轴是“完备”的，即数轴上不存在任何“洞”。\n有理数的局限性： 有理数集虽然也具有稠密性（任意两个有理数之间仍有有理数），但它不具备连续性。如果我们只看有理数，数轴上会布满密密麻麻的“洞”，这些洞对应的正是无理数。\n# 连续性的判定：戴德金分割\n我们可以通过“戴德金分割”这一思想来直观理解连续性的差异：\n# 实数的表现：\n如果在实数轴上随机进行一次“分划”，这一刀必然会落在某个具体的实数上。这个数要么属于左半部分，要么属于右半部分。这说明实数轴是紧密相连的。\n# 有理数的表现：\n对于有理数集，我们可以构造一种特殊的切法。例如，将所有有理数按如下规则分类：\nA组： 所有平方小于2的正有理数（及负有理数）；B组： 所有平方大于2的正有理数。\n当我们试图寻找这一“刀”切在哪个有理数上时，会惊奇地发现：在有理数范围内，根本没有这个数，这就说明有理数是不完备的，他并不连续。",
    "excerpt": "# 实数\n实数集 R 区别于其他数集的最核心的两个特征是：稠密性 与 连续性。\n# 稠密性\n定义： 在实数轴上，任意两个不相等的实数之间，必然存在另一个实数。\n事实上，不仅存在一个，而是存在无穷多个实数。这一性质说明实数在直线上是“处处存在”的，不存在孤立的点。\n# 连续性\n定义： 实数轴是“完备”的，即数轴上不存在任何“洞”。\n有理数的局限性： 有理数集虽然也具有稠密性（任意两个有理数之间仍有有..."
  }
]