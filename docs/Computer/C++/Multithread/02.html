<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办">
  <meta property="og:title" content="生产消费者模型">
  <meta property="og:description" content="由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://beisent.github.io/Computer/C++/Multithread/02.html">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="生产消费者模型">
  <meta name="twitter:description" content="由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办">
  <title>生产消费者模型 - BeisentDocs</title>
  <link rel="stylesheet" href="../../../static/css/style.css">
  <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css" disabled>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</head>
<body class="doc-page">
  <header class="navbar">
    <div class="navbar-inner">
      <a href="../../../index.html" class="navbar-brand">BeisentDocs</a>
      <nav class="navbar-nav">
        <a href="https://github.com/beisent">GitHub</a>
      </nav>
      <div class="navbar-actions">
        <button id="search-toggle" class="icon-btn" title="Search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
          </svg>
        </button>
        <button id="theme-toggle" class="icon-btn" title="Toggle theme">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
          </svg>
        </button>
        <button id="sidebar-toggle" class="icon-btn" title="Toggle sidebar">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        </button>
      </div>
    </div>
  </header>

  <div class="doc-layout">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-inner">
        <div class="nav-group"></div><details class="nav-section" open><summary class="nav-section-title"><a href="../../index.html" class="nav-section-link">计算机</a></summary><div class="nav-section-content"><details class="nav-section" open><summary class="nav-section-title"><a href="../index.html" class="nav-section-link">C++</a></summary><div class="nav-section-content"><details class="nav-section" open><summary class="nav-section-title"><a href="index.html" class="nav-section-link">Multithread</a></summary><div class="nav-section-content"><a href="01.html" class="nav-link">多线程编程入门</a><a href="02.html" class="nav-link active">生产消费者模型</a></div></details></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../Rust/index.html" class="nav-section-link">Rust</a></summary><div class="nav-section-content"><a href="../../Rust/基本语法.html" class="nav-link">Rust 入门</a></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../CG/index.html" class="nav-section-link">Cg</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../CG/physicsSimulate/index.html" class="nav-section-link">Physicssimulate</a></summary><div class="nav-section-content"></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../CG/Rendering/index.html" class="nav-section-link">Rendering</a></summary><div class="nav-section-content"></div></details></div></details></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/index.html" class="nav-section-link">数学</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/Calculus/index.html" class="nav-section-link">微积分</a></summary><div class="nav-section-content"><a href="../../../Math/Calculus/01.html" class="nav-link">实数</a></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/LinearAlgebra/index.html" class="nav-section-link">线性代数</a></summary><div class="nav-section-content"></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/ODE/index.html" class="nav-section-link">常微分方程</a></summary><div class="nav-section-content"></div></details></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Physics/index.html" class="nav-section-link">物理</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../../Physics/ClassicalMechanics/index.html" class="nav-section-link">理论力学</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../../Physics/ClassicalMechanics/质点运动学/index.html" class="nav-section-link">质点运动学</a></summary><div class="nav-section-content"></div></details></div></details></div></details>
      </div>
    </aside>

    <main class="doc-content">
      <nav class="breadcrumbs"><a href="../../../index.html" class="breadcrumb-link">Home</a><span class="breadcrumb-sep">/</span><a href="../../index.html" class="breadcrumb-link">计算机</a><span class="breadcrumb-sep">/</span><a href="../index.html" class="breadcrumb-link">C++</a><span class="breadcrumb-sep">/</span><a href="index.html" class="breadcrumb-link">Multithread</a><span class="breadcrumb-sep">/</span><span class="breadcrumb-current">生产消费者模型</span></nav>
      <article class="prose">
        <h1 id="生产消费者模型"><a class="anchor" href="#生产消费者模型">#</a> 生产消费者模型</h1>
<p>由于不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃不同线程处理任务和生产任务的速度是不一致的，比如我一秒产生了100个任务，但是一秒只能处理10个任务，那么产生任务和处理任务的速度匹配不上，代办任务只会越来越多导致系统崩溃。<br></p>
<p>所以为了解决这个问题就诞生了生产消费模型<br></p>
<p>生产消费模型有以下特点: - 任务队列：用于堆放代办任务 - 生产者：用于生产任务   - 消费者：用于处理任务<br></p>
<p>实现的关键挑战 - 互斥：同一时刻只能有一个线程操作队列，防止数据损坏。 - 同步：  - 队列满时，生产者必须等待，不能撑爆内存。  - 队列空时，消费者必须等待，不能空转 CPU。  - 当状态改变（有新任务或有空位）时，及时唤醒等待的线程。</p>
<p>据此我们实现</p>
<pre><code class="language-cpp">
#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;

class MessageQueue {
public:
  void push(int val) {
    // 保证此时只有一人能推送数据
    std::unique_lock&lt;std::mutex&gt; lock(m_mutex);

    // 只有当队列不满的时候并且没有结束的时候能推送数据
    m_cv.wait(lock, [this] { return m_queue.size() &lt; m_maxSize || m_done; });

    if (m_done) {
      return;
    }

    m_queue.push(val);

    std::cout &lt;&lt; &quot;生产了一个数：&quot; &lt;&lt; val &lt;&lt; &quot; 当前还剩&quot;
              &lt;&lt; m_maxSize - m_queue.size() &lt;&lt; &quot; 个位置&quot; &lt;&lt; std::endl;
    // 通知所有人任务队列现在不空，不仅仅是消费者，生产者也会收到通知
    m_cv.notify_all();
  }

  bool pop(int &amp;val) {

    // 确保此时只有一人能拿取任务
    std::unique_lock&lt;std::mutex&gt; lock(m_mutex);
    
    // 只有当任务队列不空并且没有结束的时候能拿去任务 
    m_cv.wait(lock, [this] { return !m_queue.empty() || m_done; });

    if (m_queue.empty() &amp;&amp; m_done) {
      return false;
    }

    val = m_queue.front();
    m_queue.pop();
    
    // 提醒所有人现在任务队列不满
    m_cv.notify_all();
    return true;
  }
  void close() {
    {
      std::lock_guard&lt;std::mutex&gt; lock(m_mutex);
      m_done = true;
    }
    m_cv.notify_all();
    std::cout &lt;&lt; &quot;停止生产&quot; &lt;&lt; std::endl;
  }

private:
  std::queue&lt;int&gt; m_queue;
  std::mutex m_mutex;
  std::condition_variable m_cv;
  const size_t m_maxSize = 5;
  bool m_done = false;
};
int main() {

  MessageQueue mq;
  std::vector&lt;std::thread&gt; producers;
  std::vector&lt;std::thread&gt; consumers;

  for (int i = 0; i &lt; 3; ++i) {
    producers.emplace_back([&amp;mq, i]() {
      for (int j = 0; j &lt; 5; ++j) {
        mq.push(i * 100 + j);
      }
    });
  }

  for (int i = 0; i &lt; 2; ++i) {
    consumers.emplace_back([&amp;mq, i]() {
      int val;
      while (mq.pop(val)) {
        std::cout &lt;&lt; &quot;消费者 &quot; &lt;&lt; i &lt;&lt; &quot; 成功处理了: &quot; &lt;&lt; val &lt;&lt; std::endl;
      }
      std::cout &lt;&lt; &quot;消费者 &quot; &lt;&lt; i &lt;&lt; &quot; 已安全下班&quot; &lt;&lt; std::endl;
    });
  }

  for (auto &amp;t : producers)
    t.join();

  mq.close();

  for (auto &amp;t : consumers)
    t.join();

  std::cout &lt;&lt; &quot;所有线程已退出，程序结束。&quot; &lt;&lt; std::endl;
  return 0;
}</code></pre>
      </article>
      <nav class="doc-nav"><a href="01.html" class="doc-nav-link doc-nav-prev"><span class="doc-nav-label">← 上一篇</span><span class="doc-nav-title">多线程编程入门</span></a><a href="../../Rust/基本语法.html" class="doc-nav-link doc-nav-next"><span class="doc-nav-label">下一篇 →</span><span class="doc-nav-title">Rust 入门</span></a></nav>
      <footer class="doc-footer">
        <p>&copy; 2026 Beisent Lab</p>
      </footer>
    </main>

    <aside class="toc-sidebar" id="toc-sidebar">
      <nav class="toc"><h4>On this page</h4><ul><li style="padding-left:0px"><a href="#生产消费者模型" class="toc-link" data-level="1">生产消费者模型</a></li></ul></nav>
    </aside>
  </div>

  <div class="sidebar-overlay" id="sidebar-overlay"></div>

  <!-- Search Modal -->
  <div id="search-modal" class="search-modal">
    <div class="search-modal-content">
      <div class="search-input-wrapper">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
        </svg>
        <input type="text" id="search-input" placeholder="搜索文档..." autocomplete="off">
        <button id="search-close" class="search-close">ESC</button>
      </div>
      <div id="search-results" class="search-results"></div>
    </div>
  </div>

  <button id="back-to-top" class="back-to-top" title="Back to top">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <script src="../../../static/js/main.js"></script>
  <script>
    hljs.highlightAll();
    renderMathInElement(document.querySelector('.prose'), {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '\\(', right: '\\)', display: false},
      ],
      throwOnError: false
    });
  </script>
</body>
</html>
