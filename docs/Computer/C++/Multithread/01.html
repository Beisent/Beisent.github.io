<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="C++ 多线程编程基础，包括线程创建、互斥锁、条件变量与原子操作">
  <meta property="og:title" content="多线程编程入门">
  <meta property="og:description" content="C++ 多线程编程基础，包括线程创建、互斥锁、条件变量与原子操作">
  <meta property="og:type" content="article">
  <meta property="og:url" content="https://beisent.github.io/Computer/C++/Multithread/01.html">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="多线程编程入门">
  <meta name="twitter:description" content="C++ 多线程编程基础，包括线程创建、互斥锁、条件变量与原子操作">
  <title>多线程编程入门 - BeisentDocs</title>
  <link rel="stylesheet" href="../../../static/css/style.css">
  <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark-dimmed.min.css" disabled>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
</head>
<body class="doc-page">
  <header class="navbar">
    <div class="navbar-inner">
      <a href="../../../index.html" class="navbar-brand">BeisentDocs</a>
      <nav class="navbar-nav">
        <a href="https://github.com/beisent">GitHub</a>
      </nav>
      <div class="navbar-actions">
        <button id="search-toggle" class="icon-btn" title="Search">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
          </svg>
        </button>
        <button id="theme-toggle" class="icon-btn" title="Toggle theme">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
          </svg>
        </button>
        <button id="sidebar-toggle" class="icon-btn" title="Toggle sidebar">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>
        </button>
      </div>
    </div>
  </header>

  <div class="doc-layout">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-inner">
        <div class="nav-group"></div><details class="nav-section" open><summary class="nav-section-title"><a href="../../index.html" class="nav-section-link">计算机</a></summary><div class="nav-section-content"><details class="nav-section" open><summary class="nav-section-title"><a href="../index.html" class="nav-section-link">C++</a></summary><div class="nav-section-content"><details class="nav-section" open><summary class="nav-section-title"><a href="index.html" class="nav-section-link">Multithread</a></summary><div class="nav-section-content"><a href="01.html" class="nav-link active">多线程编程入门</a><a href="02.html" class="nav-link">生产消费者模型</a></div></details></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../Rust/index.html" class="nav-section-link">Rust</a></summary><div class="nav-section-content"><a href="../../Rust/基本语法.html" class="nav-link">Rust 入门</a></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../CG/index.html" class="nav-section-link">Cg</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../CG/physicsSimulate/index.html" class="nav-section-link">Physicssimulate</a></summary><div class="nav-section-content"></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../CG/Rendering/index.html" class="nav-section-link">Rendering</a></summary><div class="nav-section-content"></div></details></div></details></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/index.html" class="nav-section-link">数学</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/Calculus/index.html" class="nav-section-link">微积分</a></summary><div class="nav-section-content"><a href="../../../Math/Calculus/01.html" class="nav-link">实数</a></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/LinearAlgebra/index.html" class="nav-section-link">线性代数</a></summary><div class="nav-section-content"></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Math/ODE/index.html" class="nav-section-link">常微分方程</a></summary><div class="nav-section-content"></div></details></div></details><details class="nav-section"><summary class="nav-section-title"><a href="../../../Physics/index.html" class="nav-section-link">物理</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../../Physics/ClassicalMechanics/index.html" class="nav-section-link">理论力学</a></summary><div class="nav-section-content"><details class="nav-section"><summary class="nav-section-title"><a href="../../../Physics/ClassicalMechanics/质点运动学/index.html" class="nav-section-link">质点运动学</a></summary><div class="nav-section-content"></div></details></div></details></div></details>
      </div>
    </aside>

    <main class="doc-content">
      <nav class="breadcrumbs"><a href="../../../index.html" class="breadcrumb-link">Home</a><span class="breadcrumb-sep">/</span><a href="../../index.html" class="breadcrumb-link">计算机</a><span class="breadcrumb-sep">/</span><a href="../index.html" class="breadcrumb-link">C++</a><span class="breadcrumb-sep">/</span><a href="index.html" class="breadcrumb-link">Multithread</a><span class="breadcrumb-sep">/</span><span class="breadcrumb-current">多线程编程入门</span></nav>
      <article class="prose">
        <h1 id="多线程编程入门"><a class="anchor" href="#多线程编程入门">#</a> 多线程编程入门</h1>
<p>多线程编程是一个非常强大的功能，现代 CPU 通常有多个核心，如果你不使用多线程编程那么所有的代码都会跑在同一个 CPU 核心上，其他的核心都被闲置极大的浪费的计算资源。<br></p>
<h2 id="创建一个线程"><a class="anchor" href="#创建一个线程">#</a> 创建一个线程</h2>
<p>在 C++11 及以上版本中使用多线程编程非常简单，C++11 标准提供了强大的 std::thread<br></p>
<p>我们可以这样创建一个线程并且传递一个函数指针作为这个线程的任务，这个函数将会在创建的子线程上运行<br></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void print() { std::cout &lt;&lt; &quot;我工作在子线程上！！&quot; &lt;&lt; std::endl; }

int main() {
  std::thread t1(print);
  std::cout &lt;&lt; &quot;主线程结束！&quot; &lt;&lt; std::endl;
  return 0;
}</code></pre>
<p>编译再运行后会发现并没有按照我们的心意运行<br></p>
<pre><code>主线程结束！
terminate called without an active exception
我工作在子线程上！！
[1]    30674 IOT instruction (core dumped)  ./a.out</code></pre>
<p>这是因为我们将任务交给子线程后主线程还会继续执行，子线程的创建和调用还会使用很多时间，但是主线程依旧继续执行并结束，子线程依旧在后台执行。   通常情况下主线程的生命周期都会比子线程长，所以我们需要让子线程等待子线程执行完毕再继续执行下面的代码，这时候我们可以这么写。<br></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

void print() { std::cout &lt;&lt; &quot;我工作在子线程上！！&quot; &lt;&lt; std::endl; }

int main() {
  std::thread t1(print);
  t1.join();
  std::cout &lt;&lt; &quot;主线程结束！&quot; &lt;&lt; std::endl;
  return 0;
}</code></pre>
<p>此时再执行会发现正常<br></p>
<pre><code>我工作在子线程上！！
主线程结束！</code></pre>
<h2 id="数据竞争与互斥锁"><a class="anchor" href="#数据竞争与互斥锁">#</a> 数据竞争与互斥锁</h2>
<h3 id="mutex"><a class="anchor" href="#mutex">#</a> Mutex</h3>
<p>我们先看这么一段程序 <br></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;thread&gt;

int cnt = 0;

void plus10000() {
  for (int i = 0; i &lt; 10000; ++i) {
    cnt++;
  }
}

int main() {
  for (int i = 0; i &lt; 10; ++i) {
    std::thread t1(plus10000);
    std::thread t2(plus10000);
    t1.join();
    t2.join();
    std::cout &lt;&lt; &quot;cnt : &quot; &lt;&lt; cnt &lt;&lt; std::endl;
    cnt = 0;
  }
  return 0;
}</code></pre>
<p>这段程序分别用两个子线程给 cnt 加 10000 10次，我们期望的结果是 20000   但是我们运行后发现并不是所有的结果都是20000</p>
<pre><code>cnt : 10556
cnt : 20000
cnt : 20000
cnt : 19767
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000</code></pre>
<p>这是因为我们两个线程如果很巧，在同一时间点同时执行了获取 cnt 的值并对其+1; 详细分析<br></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">1</th><th style="text-align:left">2</th><th style="text-align:left">3</th></tr></thead><tbody><tr><td style="text-align:left"><strong>t1</strong></td><td style="text-align:left">获取 cnt 的值, 例如 10</td><td style="text-align:left">+1 变成 11</td><td style="text-align:left">写入 cnt 此时 cnt 是 11</td></tr><tr><td style="text-align:left"><strong>t2</strong></td><td style="text-align:left">获取 cnt 的值, 也是 10</td><td style="text-align:left">+1 变成 11</td><td style="text-align:left">写入 cnt 此时 cnt 是 11</td></tr></tbody></table></div>
<p>这就发生了数据竞争。<br></p>
<p>为了解决这个问题我们需要给数据上锁，上锁的作用就是将一段操作只能被唯一线程所有直到解锁。   在上面的问题就是我们对 cnt++ 操作上锁，在执行的时候线程t1,t2都会去尝试获取这个锁的"所有权"，如果这时 t2 获取了锁的所有权，那么 t1 就无法执行这步操作了直到 t2 将锁释放，t1 才有机会获取锁的所有权去执行。</p>
<p>在 C++ 中 std::mutex 就是这个锁，我们可以这样使用这个锁</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

int cnt = 0;
std::mutex mt;
void plus10000() {
  for (int i = 0; i &lt; 10000; ++i) {
    mt.lock();
    cnt++;
    mt.unlock();
  }
}

int main() {
  for (int i = 0; i &lt; 10; ++i) {
    std::thread t1(plus10000);
    std::thread t2(plus10000);
    t1.join();
    t2.join();
    std::cout &lt;&lt; &quot;cnt : &quot; &lt;&lt; cnt &lt;&lt; std::endl;
    cnt = 0;
  }
  return 0;
}</code></pre>
<p>此时我们的输出为</p>
<pre><code>cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000
cnt : 20000</code></pre>
<h3 id="unique_lock"><a class="anchor" href="#unique_lock">#</a> unique_lock</h3>
<p>使用 mutex 每次都要手动 lock 和 unlock 太麻烦了，所以 C++ 标准库提供了一个类似 unique_qtr 的操作使用 C++ RAII 的性质封装了一个 unique_lock 当实例离开了作用域自动释放。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

int cnt = 0;
std::mutex mt;

void plus10000() {
  for (int i = 0; i &lt; 10000; ++i) {
    std::unique_lock&lt;std::mutex&gt; ulock(mt);
    cnt++;
  }
}

int main() {
  for (int i = 0; i &lt; 10; ++i) {
    std::thread t1(plus10000);
    std::thread t2(plus10000);
    t1.join();
    t2.join();
    std::cout &lt;&lt; &quot;cnt : &quot; &lt;&lt; cnt &lt;&lt; std::endl;
    cnt = 0;
  }
  return 0;
}</code></pre>
<h3 id="死锁"><a class="anchor" href="#死锁">#</a> 死锁</h3>
<p>死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种互相等待的僵局</p>
<pre><code class="language-cpp">#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex mtx1;
std::mutex mtx2;

void taskA() {
  mtx1.lock();
  std::cout &lt;&lt; &quot;线程 A：成功获取 mtx1，正在尝试获取 mtx2...&quot; &lt;&lt; std::endl;

  // 让线程A睡一会让线程B有机会获取 mtx2，否则线程A获取了mtx2就不会发生死锁现象
  std::this_thread::sleep_for(std::chrono::milliseconds(100));

  mtx2.lock();
  std::cout &lt;&lt; &quot;线程 A：成功获取 mtx2！&quot; &lt;&lt; std::endl;

  mtx2.unlock();
  mtx1.unlock();
}

void taskB() {
  mtx2.lock();
  std::cout &lt;&lt; &quot;线程 B：成功获取 mtx2，正在尝试获取 mtx1...&quot; &lt;&lt; std::endl;

  // 同理如果线程B先执行则睡一会
  std::this_thread::sleep_for(std::chrono::milliseconds(100));

  mtx1.lock();
  std::cout &lt;&lt; &quot;线程 B：成功获取 mtx1！&quot; &lt;&lt; std::endl;

  mtx1.unlock();
  mtx2.unlock();
}

int main() {
  std::thread t1(taskA);
  std::thread t2(taskB);

  t1.join();
  t2.join();

  std::cout &lt;&lt; &quot;主线程：程序结束&quot; &lt;&lt; std::endl;
  return 0;
}</code></pre>
<p>如果线程A执行的比较快则会先获取 mtx1 然后睡一会，让线程B获取 mtx2，此时线程A想获取 mtx2 线程B想获取 mtx1 都在对方的手中但是对方都在等待对方释放锁，但是不获取对方的锁又没办法释放，所以就陷入了这么一个尴尬的局面，我等你你等我永远卡住。<br></p>
<h2 id="条件变量"><a class="anchor" href="#条件变量">#</a> 条件变量</h2>
<p>有时候我们的任务必须是有顺序执行的，例如我们想让 任务B 在 任务A 执行完成之后执行，但是多线程是不会管任务的顺序的，只要一个线程拿到了一个任务，他就会一股脑执行完。 所以 C++ 提供了条件变量以解决这个问题</p>
<pre><code class="language-cpp">#include &lt;condition_variable&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;thread&gt;

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void prepareThings() {
  std::cout &lt;&lt; &quot;线程1：任务A 执行中&quot; &lt;&lt; std::endl;
  {
    std::unique_lock&lt;std::mutex&gt; ulock(mtx);
    ready = true;
    std::cout &lt;&lt; &quot;线程1：任务A 已经完成&quot; &lt;&lt; std::endl;
  }
  cv.notify_one();
}

void doSomeing() {
  std::unique_lock&lt;std::mutex&gt; ulock(mtx);
  std::cout &lt;&lt; &quot;线程2：等代 任务A 完成&quot; &lt;&lt; std::endl;
  cv.wait(ulock, [] { return ready; });
  std::cout &lt;&lt; &quot;线程2：任务B 已经完成&quot; &lt;&lt; std::endl;
}

int main() {
  std::thread t1(prepareThings);
  std::thread t2(doSomeing);
  t1.join();
  t2.join();
  return 0;
}</code></pre>
<p>在上面的代码中，cv.wait() 是核心。它接收两个参数：一个是 ulock，另一个是返回布尔值的 Lambda 表达式。   这行代码做了三件事：首先释放锁 ulock 并让线程进入等待状态；其次，当被唤醒时，它会重新获取锁；最后，它会检查 Lambda 表达式 [] { return ready; } 是否为 true。<br></p>
<p>cv.notify_one() 会唤醒一个正在等待的线程；如果有多个线程在等，可以使用 cv.notify_all()。</p>
<h2 id="原子操作"><a class="anchor" href="#原子操作">#</a> 原子操作</h2>
<p>虽然使用 mutex 解决了 cnt++ 的数据竞争问题，但互斥锁是操作系统层面的锁，对于这种简单的数学运算来说，性能开销其实很大   为了进一步优化，C++11 提供了原子类型 std::atomic <br></p>
<p>原子操作是指不可中断的操作。在多线程环境下，原子操作要么做完，要么没做，不会出现“中间态”。它直接通过 CPU 指令保证安全，不需要加锁<br></p>
<p>我们将之前的 int cnt 改为 std::atomic<int> cnt：</p>
<pre><code class="language-cpp">
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;atomic&gt;
std::atomic&lt;int&gt; cnt(0); 

void plus10000() {
  for (int i = 0; i &lt; 10000; ++i) {
    cnt++; 
  }
}

int main() {
  for (int i = 0; i &lt; 10; ++i) {
    std::thread t1(plus10000);
    std::thread t2(plus10000);
    t1.join();
    t2.join();
    std::cout &lt;&lt; &quot;cnt : &quot; &lt;&lt; cnt &lt;&lt; std::endl;
    cnt = 0;
  }
  return 0;
}</code></pre>
<p>编译并运行，你会发现结果永远是稳定的 20000  <br></p>
      </article>
      <nav class="doc-nav"><div></div><a href="02.html" class="doc-nav-link doc-nav-next"><span class="doc-nav-label">下一篇 →</span><span class="doc-nav-title">生产消费者模型</span></a></nav>
      <footer class="doc-footer">
        <p>&copy; 2026 Beisent Lab</p>
      </footer>
    </main>

    <aside class="toc-sidebar" id="toc-sidebar">
      <nav class="toc"><h4>On this page</h4><ul><li style="padding-left:0px"><a href="#多线程编程入门" class="toc-link" data-level="1">多线程编程入门</a></li><li style="padding-left:12px"><a href="#创建一个线程" class="toc-link" data-level="2">创建一个线程</a></li><li style="padding-left:12px"><a href="#数据竞争与互斥锁" class="toc-link" data-level="2">数据竞争与互斥锁</a></li><li style="padding-left:24px"><a href="#mutex" class="toc-link" data-level="3">Mutex</a></li><li style="padding-left:24px"><a href="#unique_lock" class="toc-link" data-level="3">unique_lock</a></li><li style="padding-left:24px"><a href="#死锁" class="toc-link" data-level="3">死锁</a></li><li style="padding-left:12px"><a href="#条件变量" class="toc-link" data-level="2">条件变量</a></li><li style="padding-left:12px"><a href="#原子操作" class="toc-link" data-level="2">原子操作</a></li></ul></nav>
    </aside>
  </div>

  <div class="sidebar-overlay" id="sidebar-overlay"></div>

  <!-- Search Modal -->
  <div id="search-modal" class="search-modal">
    <div class="search-modal-content">
      <div class="search-input-wrapper">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/>
        </svg>
        <input type="text" id="search-input" placeholder="搜索文档..." autocomplete="off">
        <button id="search-close" class="search-close">ESC</button>
      </div>
      <div id="search-results" class="search-results"></div>
    </div>
  </div>

  <button id="back-to-top" class="back-to-top" title="Back to top">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="18 15 12 9 6 15"></polyline>
    </svg>
  </button>

  <script src="../../../static/js/main.js"></script>
  <script>
    hljs.highlightAll();
    renderMathInElement(document.querySelector('.prose'), {
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '\\(', right: '\\)', display: false},
      ],
      throwOnError: false
    });
  </script>
</body>
</html>
